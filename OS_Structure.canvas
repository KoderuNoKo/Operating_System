{
	"nodes":[
		{"id":"95a78c02a9f9e335","type":"group","x":-9480,"y":-3040,"width":7480,"height":5600,"label":"Memory Management"},
		{"id":"c4fdf21383a31190","type":"group","x":-1000,"y":-520,"width":3560,"height":3152,"label":"OS"},
		{"id":"a8de4aed3a46c63f","type":"group","x":-7440,"y":400,"width":3440,"height":2097,"label":"Physical Memory "},
		{"id":"14426d6a56510633","type":"group","x":-9360,"y":-2960,"width":4320,"height":1240,"label":"Virtual Memory (mm-vm.c)"},
		{"id":"d781415af2d3bfe3","type":"group","x":-7760,"y":-1500,"width":3000,"height":1740,"label":"Paging (mm-vm.c)"},
		{"id":"1827ebd658882d3e","type":"group","x":-4660,"y":-1600,"width":2580,"height":1880,"label":"TLB"},
		{"id":"e373c2f1617f6085","type":"group","x":240,"y":1280,"width":2040,"height":1280,"label":"Timer"},
		{"id":"9f2fe83dadc24af5","type":"group","x":2680,"y":-280,"width":2560,"height":890,"label":"Scheduler"},
		{"id":"92d48e0cd96843f2","type":"group","x":-4620,"y":-1180,"width":1560,"height":1420,"label":"TLB cache"},
		{"id":"49b074883bb052f4","type":"group","x":-920,"y":-440,"width":1760,"height":942,"label":"Loader"},
		{"id":"ae75d0917ff485e0","type":"group","x":-1000,"y":-1640,"width":1720,"height":920,"label":"Process (common.h)"},
		{"id":"dfd1f10eb09bcf0d","type":"group","x":-6800,"y":1400,"width":1040,"height":957,"label":"MEMRAM"},
		{"id":"c2615da940877721","type":"group","x":-5600,"y":1400,"width":1040,"height":957,"label":"MEMSWAP (x4)"},
		{"id":"d741ecb7893ee925","type":"group","x":-11240,"y":-900,"width":600,"height":1320,"label":"Page Table Entries  (mm.c)"},
		{"id":"ba869600d38f26c7","type":"group","x":3200,"y":40,"width":1200,"height":530,"label":"Queue"},
		{"id":"5c1bae738cb8d05b","type":"group","x":1400,"y":-440,"width":760,"height":800,"label":"CPU"},
		{"id":"83c64aae90e0409d","type":"text","text":"Initialize Physical Memory (`mm-memphy.c`)\n---\n- Pointer to the Memory to be initialized (either `MEMRAM` or `MEMSWAP`) \n- Page's max size\n- Access flag (1 = random access, 0 = sequential)\n```C\nint init_memphy(struct memphy_struct *mp, int max_size, int randomflg);\n```\n- `mp` hold initialized physical memory\n- Return 0 on successful init\n","x":-3360,"y":772,"width":680,"height":308,"color":"5"},
		{"id":"08ee5012755f8b9e","type":"text","text":"Map a range of page at aligned address\n---\n```C\nint vmap_page_range(struct pcb_t *caller, // process call\n                                int addr, // start address which is aligned to pagesz\n                               int pgnum, // num of mapping page\n           struct framephy_struct *frames,// list of the mapped frames\n              struct vm_rg_struct *ret_rg)// return mapped region, the real mapped fp\n```\n- map range of frame to address space\n- `[<addr> to addr + pgnum*PAGING_PAGESZ in page table caller->mm->pgd[]`","x":-9380,"y":-1237,"width":1067,"height":297,"color":"1"},
		{"id":"5753a4cf91e0f1df","type":"text","text":"Memory Management Structure (`os-mm.h`)\n---\n```C\nstruct mm_struct \n{\n   // ptr to page table\n   uint32_t *pgd;\n\n   // list of memory areas\n   struct vm_area_struct *mmap;\n\n   // Symbol table - Currently we support a fixed number of symbol\n   struct vm_rg_struct symrgtbl[PAGING_MAX_SYMTBL_SZ];\n\n   /* list of free page */\n   struct pgn_t *fifo_pgn;\n};\n```","x":-8393,"y":-920,"width":640,"height":440,"color":"2"},
		{"id":"8168a04d3cfd8d65","type":"text","text":"Map all virtual memory areas to RAM\n---\n- PCB of calling process\n- `astart` - `aend`:  range of area ???\n- `mapstart`: the address where the mapping will start\n- `incpgnum`: the number of page to be mapped\n- returned region\n```C\nint vm_map_ram(struct pcb_t *caller, int astart, int aend, int mapstart, int incpgnum, struct vm_rg_struct *ret_rg);\n```\n- Return 0 if mapped successfully or -1 (`vm_map_ram out of memory`) \n- Otherwise if there is enough memory but some are in `MEMSWAP`","x":-9460,"y":0,"width":1054,"height":352},
		{"id":"f60082b7b26932ef","type":"text","text":"Print page table (`mm.c`)\n---\n- PCB of calling process\n- start, end\n```C\nint print_pgtbl(struct pcb_t *caller, uint32_t start, uint32_t end);\n```\n- Print entries of caller's page table from `start` to `end`\n- Return 0 if print successfully and 0 otherwise","x":-8440,"y":-1527,"width":660,"height":270},
		{"id":"8fed0f4f1dff21b9","type":"text","text":"Allocate a required number of frame in RAM\n---\n- PCB of calling process\n- required number of frame\n- Frame list ???\n```C\nint alloc_pages_range(struct pcb_t *caller, int req_pgnum, struct framephy_struct** frm_lst;\n```","x":-9363,"y":520,"width":860,"height":240},
		{"id":"ce4eaf3bbbd73d78","type":"text","text":"Enlist page node\n---\n- List of page numbers\n- Page number to be enlisted\n```C\nint enlist_pgn_node(struct pgn_t **plist, int pgn);\n```\n- Create new page number of `pgn` then put it into `plist` ","x":-9320,"y":-840,"width":527,"height":280},
		{"id":"57f73dee51e1166c","type":"text","text":"Enlist region node\n---\n- List of region\n- Region to be enlisted\n```C\nint enlist_vm_rg_node(struct vm_rg_struct **rglist, struct vm_rg_struct* rgnode);\n```\n- Put new region into list","x":-9320,"y":-380,"width":760,"height":260},
		{"id":"136b718d65cc8d8f","type":"text","text":"Print list of pages\n---\n- Pointer to the list of pages\n```C\nint print_list_rg(struct vm_rg_struct *irg);\n```","x":-9425,"y":1524,"width":484,"height":168},
		{"id":"36607e051c7379b4","type":"text","text":"Allocating new page to process\n---\n- PCB of caller process\n- Allocated size\n- ID of memory region (used to identify variable in symbol table)\n```C\nint pgalloc(struct pcb_t *proc, uint32_t size, uint32_t reg_index);\n```","x":-7740,"y":-1480,"width":800,"height":240},
		{"id":"98d14d3ab3b49cf5","type":"text","text":"Deallocating page\n---\n- PCB of caller process\n- ID of memory region \n```C\nint pgfree_data(struct pcb_t *proc, uint32_t reg_index);\n```","x":-6920,"y":-1480,"width":800,"height":240},
		{"id":"248179eea4393972","type":"text","text":"Memory Area Structure (`os-mm.h`)\n---\n```C\nstruct vm_area_struct \n{\n   unsigned long vm_id;\n   unsigned long vm_start;\n   unsigned long vm_end;\n   \n   unsigned long sbrk;\n   \n/*\n * Derived field\n * unsigned long vm_limit = vm_end - vm_start\n */\n   struct mm_struct *vm_mm; // mm_struct of the owner process\n   struct vm_rg_struct *vm_freerg_list; // head of the SLL of free regions\n   struct vm_area_struct *vm_next;\n};\n```\n- Each process can associated with multiple areas \n- Each areas spans continuously in virtual memory from `vm_start` to `vm_end`, but only the interval [`vm_start`, `sbrk`] is usable\n- A Memory Area contains multiple regions","x":-5980,"y":-2940,"width":720,"height":600,"color":"2"},
		{"id":"8bd0be18f540c48b","type":"text","text":"Memory Region Structure (`os-mm.h`)\n---\n```C\n#define PAGING_MAX_SYMTBL_SZ 30 \nstruct vm_rg_struct \n{\n   unsigned long rg_start;\n   unsigned long rg_end;\n\n   struct vm_rg_struct *rg_next;\n};\n```\n- Acts as variables in code","x":-5980,"y":-2300,"width":720,"height":320,"color":"2"},
		{"id":"6a53805c09ee238c","type":"text","text":"Page Number (`os-mm.h`)\n---\n```C\nstruct pgn_t {\n   int pgn;\n   struct pgn_t *pg_next;\n};\n```","x":-5980,"y":-1940,"width":720,"height":200,"color":"2"},
		{"id":"edd4777840d4c721","type":"text","text":"Enlist free region to Free Region list \n---\n- `mm_struct` of process\n- new free region\n```C\nint enlist_vm_freerg_list(struct mm_struct *mm, struct vm_rg_struct rg_elmt);\n```\n- Put the new free region into list of free regions\n- Return 0 is enlist successfully and -1 otherwise","x":-6900,"y":-2900,"width":760,"height":280},
		{"id":"195e69fcabab2409","type":"text","text":"Deallocating region\n---\n- Calling process\n- ID of memory area & region\n```C\nint __free(struct pcb_t *caller, int vmaid, int rgid);\n```\n- free the designated memory region","x":-6800,"y":-2010,"width":560,"height":240,"color":"1"},
		{"id":"1bc574c12922b5be","type":"text","text":"Format Physical Memory (`mm-memphy.c`)\n---\n- Memory to be formatted\n- Page size\n```C\nint MEMPHY_format(struct memphy_struct *mp, int pagesz);\n```\n- Divide memory into fixed size frames. Inputted pointer `mp` become the head of the SLL of frames\n- Return 0 if divide successfully. -1 otherwise","x":-3360,"y":1260,"width":680,"height":320},
		{"id":"27118849d31bcae4","type":"text","text":"Print list of frames\n---\n- Pointer to the list of frames\n```C\nint print_list_fp(struct framephy_struct *ifp);\n```","x":-9425,"y":1356,"width":484,"height":168},
		{"id":"fd65ea4b87fa176b","type":"text","text":"Get Memory Region at current limit \n---\n- Calling process\n- ID of the area whose size will be increased\n- The amount of space to be increased\n- `alignedsz` ????\n```C\nstruct vm_rg_struct* get_vm_area_node_at_brk(struct pcb_t *caller, int vmaid, int size, int alignedsz);\n```\n- New region beyond `sbrk` limit","x":-8840,"y":-2040,"width":960,"height":300},
		{"id":"28ccab1b30292b51","type":"text","text":"Find victim page\n---\n- `mm-struct` of calling process\n- A container for the returned victim page\n```C\nint find_victim_page(struct mm_struct *mm, int *retpgn);\n```\n- Return 0","x":-6400,"y":-970,"width":640,"height":240},
		{"id":"637c213dd6fbc3e5","type":"text","text":"Get page\n---\n- `mm_struct` of calling process\n- index of target page\n- Container for the returned frame number whose targeted page is in\n- PCB of calling process ???\n```C\nint pg_getpage(struct mm_struct *mm, int pgn, int *fpn, struct pcb_t *caller);\n```\n- Return 0 if succeeded","x":-6460,"y":-585,"width":760,"height":310,"color":"1"},
		{"id":"6c4ecbab9c5d7a8a","type":"text","text":"Sequential Physical Memory Read/Write\n---\n- Memory page contain desired data\n- Address in page (i.e. offset)\n- Container to retrieve data / value to be written\n```C\nint MEMPHY_seq_read(struct memphy_struct *mp, int addr, BYTE *value);\nint MEMPHY_seq_write(struct memphy_struct * mp, int addr, BYTE value);\n```\n- Save read data into `value` / write `value` to memory\n- Return 0 is read/write successfully and -1 otherwise","x":-6280,"y":440,"width":680,"height":320},
		{"id":"4e0d83c65f17720d","type":"text","text":"Memory Dump (`mm-memphy.c`)\n---\n- Page to be dumped\n```C\nint MEMPHY_dump(struct memphy_struct * mp);\n```\n- Print out all contents of the dumped page","x":-4840,"y":611,"width":680,"height":217,"color":"1"},
		{"id":"f0b64d9dd45a2ff3","type":"text","text":"Free all Physical memory of a process\n---\n- PCB of calling process\n```C\nint free_pcb_memph(struct pcb_t *caller);\n```\n\n- Return 0 when finished","x":-7440,"y":-167,"width":500,"height":210},
		{"id":"9211fb36752552ea","type":"text","text":"Physical Memory Read/Write (`mm-memphy.c`)\n---\n- Pointer to memory, either `MEMRAM` or `MEMSWAP`\n- Address\n- Container to retrieve data / contain value to be written\n```C\nint MEMPHY_read(struct memphy_struct * mp, int addr, BYTE *value)\nint MEMPHY_write(struct memphy_struct * mp, int addr, BYTE data);\n```\n- Save read data into `value` / write `value` to memory\n- Return 0 is read/write successfully and -1 otherwise","x":-7160,"y":420,"width":680,"height":360},
		{"id":"b2791855331ed53b","type":"text","text":"","x":-8275,"y":-1365,"width":250,"height":60},
		{"id":"6c6cc52bdffcd903","type":"text","text":"Validate overlap Memory Area \n---\n- Calling process \n- ID of validating Area\n- `rg_start` of new region\n- `rg_end` of new region\n```C\nint validate_overlap_vm_area(struct pcb_t *caller, int vmaid, int vmastart, int vmaend);\n```\n- Return 0 if valid and -1 otherwise","x":-7860,"y":-2040,"width":840,"height":300},
		{"id":"8a1f8cc89ebe32a5","type":"text","text":"Get Virtual Memory Area/Region by ID \n---\n- `mm_struct` of process\n- ID `vm_area` to allocate memory region / region ID act as symbol index of variable\n```C\nstruct vm_area_struct *get_vma_by_num(struct mm_struct *mm, int vmaid);\nstruct vm_rg_struct *get_symrg_byid(struct mm_struct *mm, int rgid)\n```\n- Area/region whose id is match ","x":-7860,"y":-2900,"width":680,"height":280},
		{"id":"cdfd91991821d0a6","type":"text","text":"Allocating region to process \n---\n- PCB of caller process\n- designated `vm_area` \n- designated `vm_rg`\n- size required by the process\n- container address to the start of the allocated region\n```C\nint __alloc(struct pcb_t *caller, int vmaid, int rgid, int size, int *alloc_addr)\n```\n- Return 0 on successful allocation\n- Handle cases where no free `vm_rg` is available, by Increasing `vm_area` limit to get space","x":-9340,"y":-2940,"width":800,"height":360,"color":"1"},
		{"id":"b87529e010c9cc32","type":"text","text":"Increase Memory Area limit \n---\n- Calling process\n- ID of the area whose size will be increased\n- The amount of space `inc_sz` to be increased\n```C\nint inc_vma_limit(struct pcb_t *caller, int vmaid, int inc_sz);\n```\n- Return 0 on success and -1 otherwise (overlap)","x":-9274,"y":-2460,"width":680,"height":280},
		{"id":"1d2527a7dbeed805","type":"text","text":"Get a free memory region from designated area (`vm-mm.c`)\n---\n- PCB of calling process\n- ID of designated area\n- required region size\n- A container for returned allocated region\n```C\nint get_free_vmrg_area(struct pcb_t *caller, int vmaid, int size, struct vm_rg_struct *newrg);\n```\n- Return 0 if allocated successfully and -1 if region not found","x":-9380,"y":-1680,"width":923,"height":305},
		{"id":"7a5ac043a4fceaa3","type":"text","text":"Initialize Virtual Memory Region (`mm.c`)\n---\n- `start` & `end` of new memory region\n```C\nstruct vm_rg_struct* init_vm_rg(int rg_start, int rg_end);\n```\n- Return created region","x":-2640,"y":-2250,"width":585,"height":220},
		{"id":"c8ff83d467c7f558","type":"text","text":"Print list of Virtual memory Areas\n---\n- Pointer to the list of areas\n```C\nint print_list_vma(struct vm_area_struct *ivma);\n```","x":-9425,"y":1692,"width":505,"height":168},
		{"id":"44cc34b38c9c236b","type":"text","text":"Set swap bit\n---\n- Target PTE\n- Swap type\n- swap offset\n```C\nint pte_set_swap(uint32_t *pte, int swptyp, int swpoff);\n```","x":-11220,"y":-880,"width":560,"height":260},
		{"id":"dd47a314e1c56648","type":"text","text":"Set frame page number\n---\n- Target PTE\n- Swap type\n- Frame page number\n```C\nint pte_set_fpn(uint32_t *pte, int fpn);\n```","x":-11220,"y":-620,"width":560,"height":260},
		{"id":"d0e2e549e15f6a22","type":"text","text":"Initialize Page table entries\n---\n```C\nint init_pte(uint32_t *pte,\n             int pre,    // present\n             int fpn,    // FPN\n             int drt,    // dirty\n             int swp,    // swap\n             int swptyp, // swap type\n             int swpoff); //swap offset\n```","x":-10280,"y":-380,"width":600,"height":282},
		{"id":"9a2f46cd9c084509","type":"text","text":"Stop timer\n---\n- called when simulation ends\n```C\nvoid stop_timer();\n```\n- Clean resources allocated to `timer_id` list","x":392,"y":1920,"width":416,"height":240},
		{"id":"50cb7971f54e2405","type":"text","text":"Timer id\n---\n```C\nstruct timer_id_t {\n    int done; // flag indicate process used up time slot\n    int fsh; //flag indicate process finished all its operation\n\n// condition variable associated w/ the above flags, used \n// to notify to other threads as needed\n    pthread_cond_t event_cond;\n// lock to protect the above flags\n    pthread_mutex_t event_lock;\n\n// At end of a time slot\n// tasks must wait for this condition to move to next slot\n    pthread_cond_t timer_cond;\n// lock to protect the timer \n    pthread_mutex_t timer_lock;\n};\n```","x":1000,"y":2020,"width":680,"height":500,"color":"2"},
		{"id":"d474dd22742eb061","type":"text","text":"Timer id container\n---\n```C\n// head ptr of the SLL of timer_id \nstatic struct timer_id_container_t * dev_list = NULL;\n// each node is a timer_id\nstruct timer_id_container_t {\n    struct timer_id_t id;\n    struct timer_id_container_t * next;\n};\n```","x":320,"y":2240,"width":600,"height":280,"color":"2"},
		{"id":"466b81bdfb18ea2c","type":"text","text":"Detach event\n---\n```C\nvoid detach_event(struct timer_id_t * event)\n```\n- Set the `fsh` condition","x":1720,"y":1720,"width":515,"height":240},
		{"id":"7f19d077a16f03bd","type":"text","text":"Print list of page numbers\n---\n- Pointer to the list of page numbers\n```C\nint print_list_pgn(struct pgn_t *ip);\n```","x":-9425,"y":1860,"width":484,"height":168},
		{"id":"80d09e8f471be1b3","type":"text","text":"`path` field specify the process to be loaded\n\n```C\nstruct pcb_t * load(const char * path);\n```\nPCB of the created process","x":220,"y":29,"width":500,"height":158},
		{"id":"61c1e32591693c93","type":"text","text":"string `opt` represent the type of instruction\n```C\nstatic enum ins_opcode_t get_opcode(char * opt);\n```\nOne of the defined type of intruction (see `enum ins_opcode_t` in `common.h`)","x":160,"y":-361,"width":620,"height":184},
		{"id":"ff2694d796d4c052","type":"text","text":"Loader Routine (in `OS.c`)\n---\n- If `MM_PAGING` is defined: `struct mmpaging_ld_args`\n- else `ld_event`\n```C\nstatic void * ld_routine(void * args) \n```\n- Thread holder for created process\n- Pass arguments to `mm_struct` to allocate memory for process","x":-790,"y":108,"width":540,"height":292},
		{"id":"bb533130e355a147","type":"text","text":"Add process\n---\nNew process to be added to ready queue\n```C\nvoid add_proc(struct pcb_t * proc);\n```","x":2720,"y":272,"width":390,"height":160},
		{"id":"42ce24d63349948a","type":"text","text":"Dequeue\n---\n- Queue\n```C\nstruct pcb_t * dequeue(struct queue_t * q);\n```\n- Return a process from the queue","x":3225,"y":55,"width":600,"height":228,"color":"1"},
		{"id":"f7acb79a5bc217e5","type":"text","text":"Config reader (in `OS.c`)\n---\nInput:\nDirectory to the config file (files in input directory) of the  desired process\n```C\nstatic void read_config(const char * path);\n```\nOutput:\n- Read the config files for simulated OS configuration\n- Read configurations for defined modules ","x":-720,"y":1270,"width":640,"height":300},
		{"id":"a0d46b91e3c9b2b1","type":"text","text":"Arguments for Loader (in `OS.c`)\n---\n```C\nstatic int memramsz;                   // size of main memory\nstatic int memswpsz[PAGING_MAX_MMSWP]; // size of swap space\n\nstruct mmpaging_ld_args\n{\n/* A dispatched argument struct to compact many-fields passing to loader */\n    struct memphy_struct *tlb;\n    struct memphy_struct *mram;\n    struct memphy_struct **mswp;\n    struct memphy_struct *active_mswp;\n    struct timer_id_t  *timer_id;\n};\n```","x":-880,"y":-408,"width":720,"height":388,"color":"2"},
		{"id":"8f093478bbfff797","type":"text","text":"Get process\n---\n```C\nstruct pcb_t * get_proc(void);\n```\nA process from the ready queue","x":2720,"y":-228,"width":390,"height":180},
		{"id":"5561d46662ec9e5b","type":"text","text":"Get process from MLQ (`sched.c`)\n---\n```C\nstruct pcb_t * get_mlq_proc(void)\n```\nRetrieve a process from the ready queue","x":3280,"y":-238,"width":490,"height":200,"color":"1"},
		{"id":"d7feb4fec86c6970","type":"text","text":"Initialization\n---\n```C\nvoid init_scheduler(void);\n```","x":4560,"y":-166,"width":520,"height":140},
		{"id":"993f8500eaea462b","type":"text","text":"Queue\n---\n```C\nstatic struct queue_t ready_queue;\nstatic struct queue_t run_queue;\nstatic pthread_mutex_t queue_lock;\n\nstatic struct queue_t mlq_ready_queue[MAX_PRIO];\n```","x":4560,"y":134,"width":520,"height":298},
		{"id":"c7fda81c2ffc7611","type":"text","text":"Empty\n---\n- Queue\n```C\nint empty(struct queue_t * q)\n```\n- Return 1 if the queue is empty and 0 otherwise","x":3920,"y":172,"width":440,"height":228},
		{"id":"fd7d273366476647","type":"text","text":"Enqueue\n---\n- New process\n```C\nvoid enqueue(struct queue_t * q, struct pcb_t * proc);\n```\n- Put new process into queue","x":3225,"y":318,"width":600,"height":228,"color":"1"},
		{"id":"b156846abd081b84","type":"text","text":"Arguments for CPU (in `OS.c`)\n---\n```C\nstruct cpu_args \n{\n    struct timer_id_t * timer_id;\n    int id;\n};\n```\n1 id / CPU","x":1570,"y":-398,"width":440,"height":298},
		{"id":"42f64b2acaf42501","type":"text","text":"CPU routine (in `OS.c`)\n---\n```C\nstatic void * cpu_routine(void * args);\n```\n- Operate as CPU dispatcher \n- Initialize CPU scheduling behavior (if defined)","x":1540,"y":32,"width":500,"height":240},
		{"id":"ec1f3cc2e4ab5c15","type":"text","text":"Main\n---\n```C\nint main(int argc, char* argv[]);\n```","x":220,"y":800,"width":599,"height":160},
		{"id":"9121060332413fd5","type":"text","text":"Timer Routine\n---\n```C\nstatic void * timer_routine(void * args);\n```\n- A timer thread `_timer` for each cores","x":280,"y":1640,"width":640,"height":160},
		{"id":"9ecdd7db7df0c53b","type":"text","text":"Put process\n---\nA process to be PUT BACK in run queue (highest priority)\n```C\nvoid put_proc(struct pcb_t * proc);\n```","x":2720,"y":12,"width":390,"height":188},
		{"id":"802361c57ddba90d","type":"text","text":"Start timer\n---\n- called when simulation starts\n```C\nvoid start_timer();\n```\n- Initialize the timer","x":403,"y":1320,"width":405,"height":200},
		{"id":"fa66f3386f9f5077","type":"text","text":"Attach event\n---\n```C\nstruct timer_id_t * attach_event()\n```\nOutput:\n- Gives lock to a process","x":1080,"y":1520,"width":440,"height":200},
		{"id":"e975124d6ebff1be","type":"text","text":"Process Control Block PCB \n---\n```C\nstruct pcb_t \n{\n    uint32_t pid;   // PID\n    uint32_t priority; // Default priority, this legacy (FIXED) value depend on process itself\n    struct code_seg_t * code;   // Code segment\n    addr_t regs[10]; // Registers, store address of allocated regions\n    uint32_t pc; // Program pointer, point to the next instruction\n\n#ifdef MLQ_SCHED\n\n    // Priority on execution (if supported), on-fly aka. changeable\n    // and this vale overwrites the default priority when it existed\n    uint32_t prio;    \n\n#endif\n#ifdef CPU_TLB\n\n    struct memphy_struct *tlb;\n\n#endif\n#ifdef MM_PAGING\n\n    struct mm_struct *mm;\n    struct memphy_struct *mram;\n    struct memphy_struct **mswp;\n    struct memphy_struct *active_mswp;\n\n#endif\n\n    struct page_table_t * page_table; // Page table\n    uint32_t bp;    // Break pointer\n};\n```","x":-960,"y":-1560,"width":880,"height":780,"color":"2"},
		{"id":"d377c7df3f338286","type":"text","text":"Code Segment\n---\n- Each process associated with 1 code segment\n```C\nstruct code_seg_t \n{\n    // list of instructions\n    struct inst_t * text;\n    uint32_t size;\n};","x":80,"y":-1560,"width":560,"height":300},
		{"id":"f276335551a30219","type":"text","text":"Next slot\n---\n```C\nvoid next_slot(struct timer_id_t * timer_id);\n```\n- Set the `done` condition\n- Wait for condition and proceed to the next slot","x":1720,"y":1320,"width":515,"height":200},
		{"id":"039f11ae8db528dc","type":"text","text":"Instruction\n---\n```C\nstruct inst_t \n{\n    enum ins_opcode_t opcode;\n    \n    // Argument lists for instructions\n    uint32_t arg_0; \n    uint32_t arg_1;\n    uint32_t arg_2;\n};\n```\n- Opcode specifying instruction operation\n- Arguments passed to the instruction","x":80,"y":-1180,"width":560,"height":400},
		{"id":"ea49a7894b1bb4be","type":"text","text":"TLB Read\n---\n- PCB of the calling process\n- `Source` region index\n- offset\n- `destination` register which will store the retrieved data\n```C\nint tlbread(struct pcb_t * proc, uint32_t source, uint32_t offset,  uint32_t destination)\n```\n- Return the status of the `__read()` instruction of Virtual Memory","x":-2960,"y":-880,"width":840,"height":320,"color":"1"},
		{"id":"cda9cdcf7f27e6da","type":"text","text":"TLB Write\n---\n- PCB of the calling process\n- `data` to be written into memory\n- `destination` region index\n- offset\n```C\nint tlbwrite(struct pcb_t * proc, BYTE data, uint32_t destination, uint32_t offset);\n```\n- Return the status of the `__write()` instruction of Virtual Memory","x":-2960,"y":-530,"width":840,"height":320,"color":"1"},
		{"id":"9fd54bafd38a56d9","type":"text","text":"TLB memory dump\n---\n- `MEMPHY` struct\n```C\nint TLBMEMPHY_dump(struct memphy_struct * mp);\n```\n- dump `memphy` content `mp->storage`","x":-4600,"y":-490,"width":680,"height":240},
		{"id":"5a1e61ccdbc3f3ea","type":"text","text":"Initialize Physical Memory for TLB cache\n---\n- `mp` pointer to hold the allocated `MEMPHY`\n- `sz` size of the TLB cache\n- `(1, ##__VA_ARGS__)`: flag of initialized memory type, default to 1 (random access)\n```C\n#define init_tlbcache(mp,sz,...) init_memphy(mp, sz, (1, ##__VA_ARGS__))\n```\n- Initialize `MEMPHY` for the TLB_cache","x":-4600,"y":-40,"width":700,"height":260,"color":"5"},
		{"id":"5b076d74375ff120","type":"text","text":"Initialize Physical Memory for TLB\n---\n- `mp` pointer to hold the allocated `MEMPHY`\n- `max_size` for the TLB \n```C\nint init_tlbmemphy(struct memphy_struct *mp, int max_size);\n```\n- Initialize `MEMPHY` for the TLB","x":-3820,"y":-40,"width":740,"height":260,"color":"5"},
		{"id":"371116e11058490a","type":"text","text":"TLB cache read\n---\n- `MEMPHY` struct\n- process id\n- page number\n- `value` container for retrieved data\n```C\nint tlb_cache_read(struct memphy_struct * mp, int pid, int pgnum, BYTE value);\n```\n- identify info is mapped to cache line, employing cache mapping techniques","x":-3820,"y":-530,"width":740,"height":320,"color":"1"},
		{"id":"dbef3d0263dac663","type":"text","text":"TLB Physical Memory read/write\n---\n- `MEMPHY` struct\n- Target address\n- Read `value` / `data` to be written\n```C\nint TLBMEMPHY_read(struct memphy_struct * mp, int addr, BYTE *value);\nint TLBMEMPHY_write(struct memphy_struct * mp, int addr, BYTE data);\n```\n- Return 0 on successful read/write and -1 otherwise","x":-4600,"y":-1095,"width":680,"height":290},
		{"id":"4e36d857439193e0","type":"text","text":"TLB cache read\n---\n- `MEMPHY` struct\n- process id\n- page number\n- `value` container for retrieved data\n```C\nint tlb_cache_read(struct memphy_struct * mp, int pid, int pgnum, BYTE value);\n```\n- identify info is mapped to cache line, employing cache mapping techniques","x":-3820,"y":-880,"width":740,"height":320,"color":"1"},
		{"id":"24915e749cf8cb2a","type":"text","text":"Initialize Memory Management structure (`mm.c`)\n---\n- `mm_struct` to be initialized\n- PCB of calling process\n```C\nint init_mm(struct mm_struct *mm, struct pcb_t *caller);\n```\n- Initialize a `mm_struct` for each process\n- Initialize an empty memory region\n- then enlist it into the free region list of the `mm_struct`","x":-1800,"y":-381,"width":640,"height":281},
		{"id":"c0fe5fea091564c1","type":"text","text":"Read/Write from/to page\n---\n- PCB of calling process\n- `source` register containing region ID\n- `offset` ([source address] = [source] + [offset])\n- `destination` which to which read data is written / which containing the index for page to be written to  \n```C\nint pgread(struct pcb_t * proc, uint32_t source, uint32_t offset, uint32_t destination);\nint pgwrite(struct pcb_t * proc, BYTE data, uint32_t destination, uint32_t offset);\n```\n- Return status of `__read()`/`__write()` function","x":-5640,"y":-1480,"width":840,"height":320},
		{"id":"d4d496299db63483","type":"text","text":"Read/Write from/to region\n---\n- PCB of calling process\n- ID of designated area\n- ID of designated region\n- offset\n- `data` to contain retrieve data / `value` to be written to region\n```C\nint __read(struct pcb_t *caller, int vmaid, int rgid, int offset, BYTE *data);\nint __write(struct pcb_t *caller, int vmaid, int rgid, int offset, BYTE value);\n```\n- Return 0 if read/write successfully and 0 otherwise","x":-5600,"y":-1020,"width":760,"height":340},
		{"id":"2649b2021b07a440","type":"text","text":"get/set data in page\n---\n- `mm_struct` of calling process\n- target address\n- `data` to contain retrieve data / `value` to be written to region\n```C\nint pg_getval(struct mm_struct *mm, int addr, BYTE *data, struct pcb_t *caller);\nint pg_setval(struct mm_struct *mm, int addr, BYTE value, struct pcb_t *caller);\n```\n- Return 0 if read/write successfully and 0 otherwise","x":-5600,"y":-580,"width":760,"height":300},
		{"id":"4855abf70aa48cd0","type":"text","text":"Flush all TLB entries for a process\n---\n- PCB of process whose entries will be flushed\n- Memory structure where TLB table is located\n```C\nint tlb_flush_tlb_of(struct pcb_t *proc, struct memphy_struct * mp);\n```\n","x":-2870,"y":-1580,"width":660,"height":200,"color":"1"},
		{"id":"a79c3351d57d28c2","type":"text","text":"Update all TLB entries for a process\n---\n- PCB of process whose entries is flushed\n- Memory structure where TLB table is located\n```C\nint tlb_flush_tlb_of(struct pcb_t *proc, struct memphy_struct * mp);\n```\n","x":-2870,"y":-1230,"width":660,"height":200,"color":"1"},
		{"id":"c02223b37945f555","type":"text","text":"TLB allocation\n---\n- PCB of the calling process\n- allocated size \n- index of allocated region (used for variable identifying)\n```C\nint tlballoc(struct pcb_t *proc, uint32_t size, uint32_t reg_index);\n```\n- ","x":-4620,"y":-1580,"width":640,"height":260,"color":"1"},
		{"id":"ff63c2d239c6aa5c","type":"text","text":"","x":-3980,"y":-1180,"width":250,"height":60},
		{"id":"4f13b33d8baa6a3b","type":"text","text":"TLB Deallocation\n---\n- PCB of the calling process\n- index of region to be deallocated\n```C\nint tlballoc(struct pcb_t *proc, uint32_t size, uint32_t reg_index);\n```","x":-3960,"y":-1580,"width":640,"height":260,"color":"1"},
		{"id":"537d320d024477a5","type":"text","text":"Move Cursor (Sequential RW)\n---\n- Memory page contain desired data\n- Offset\n```C\nint MEMPHY_mv_csr(struct memphy_struct *mp, int offset);\n```\n- Move the page's cursor to Offset\n- Return 0  if move successfully","x":-6273,"y":940,"width":673,"height":277},
		{"id":"f4a61856146e5867","type":"text","text":"Get/Put free frames (`mm-memphy.c`)\n---\n- Pointer to memory, either `MEMRAM` or `MEMSWAP`\n- A container `retfpn` to obtain new frame (in form of frame index) / index of free frame to be put back\n```C\nint MEMPHY_get_freefp(struct memphy_struct *mp, int *retfpn);\nint MEMPHY_put_freefp(struct memphy_struct *mp, int fpn);\n```\n- Destroy/Create frame of input index (for simulation purpose)\n- Return 0 if there is free frame and -1 otherwise","x":-5520,"y":549,"width":620,"height":340},
		{"id":"cca61decfd5b2e94","type":"text","text":"Swap copy content page\n---\n- Physical memory of source and destination `MEMPHY` struct (i.e. `MEMRAM` or `MEMSWAP`)\n- Indices of source and destination pages\n```C\nint __swap_cp_page(struct memphy_struct *mpsrc, int srcfpn, struct memphy_struct *mpdst, int dstfpn);\n```","x":-8800,"y":780,"width":940,"height":220},
		{"id":"1b18fb732e8e129b","type":"text","text":"Physical Frame Structure (`os-mm.h`)\n---\n```C\nstruct framephy_struct \n{\n   int fpn; // page index\n   struct framephy_struct *fp_next;\n\n   /* Reserved for tracking allocated framed */\n   struct mm_struct* owner;\n};\n```\n- Memory is organized as SLL of frames","x":-7360,"y":1436,"width":540,"height":340,"color":"2"},
		{"id":"f9844c5e0897667b","type":"text","text":"Physical Memory Structure (`os-mm.h`)\n---\n```C\nstruct memphy_struct \n{\n   /* Basic field of data and size */\n   BYTE *storage;\n   int maxsz; \n   \n   /* Sequential device fields */\n   int rdmflg // access = (rdmflg) ? random : sequential\n   int cursor; // cursor in case of sequential access\n\n   /* Management structure */\n   struct framephy_struct *free_fp_list;\n   struct framephy_struct *used_fp_list;\n};\n```\n- Both `MEMRAM` and `MEMSWAP` is implemented by this structure, but different settings\n","x":-7360,"y":1796,"width":540,"height":500,"color":"2"},
		{"id":"908f47a9f951ba07","type":"text","text":"Print page table \n---\n- PCB of calling process\n- `start` and `end` index\n```C\nint print_pgtbl(struct pcb_t *caller, uint32_t start, uint32_t end)\n```","x":-8280,"y":352,"width":685,"height":232}
	],
	"edges":[
		{"id":"d2ff6b8ce49ee4bb","fromNode":"a0d46b91e3c9b2b1","fromSide":"bottom","toNode":"ff2694d796d4c052","toSide":"top","label":"Pass to"},
		{"id":"15ee0679081c2fe4","fromNode":"80d09e8f471be1b3","fromSide":"top","toNode":"61c1e32591693c93","toSide":"bottom","label":"call"},
		{"id":"ca519d5ee867d50d","fromNode":"ec1f3cc2e4ab5c15","fromSide":"top","toNode":"a0d46b91e3c9b2b1","toSide":"right","label":"init"},
		{"id":"2a5dbb63363b6e73","fromNode":"ff2694d796d4c052","fromSide":"right","toNode":"ec1f3cc2e4ab5c15","toSide":"top","color":"2","label":"thread"},
		{"id":"55b9d61d88b17cc5","fromNode":"ff2694d796d4c052","fromSide":"right","toNode":"80d09e8f471be1b3","toSide":"left","color":"5","label":"call"},
		{"id":"0968be419abb4088","fromNode":"b156846abd081b84","fromSide":"bottom","toNode":"42f64b2acaf42501","toSide":"top","label":"Pass to"},
		{"id":"4bb07df1789607e2","fromNode":"ec1f3cc2e4ab5c15","fromSide":"right","toNode":"b156846abd081b84","toSide":"left","label":"init"},
		{"id":"64015acf26e5247a","fromNode":"42f64b2acaf42501","fromSide":"bottom","toNode":"ec1f3cc2e4ab5c15","toSide":"right","color":"2","label":"thread"},
		{"id":"ca1c5907b5130cfd","fromNode":"802361c57ddba90d","fromSide":"bottom","toNode":"9121060332413fd5","toSide":"top","label":"create thread"},
		{"id":"178ec1219e99013a","fromNode":"fa66f3386f9f5077","fromSide":"right","toNode":"f276335551a30219","toSide":"left","label":"slot over?"},
		{"id":"860e88640d9b02d6","fromNode":"9a2f46cd9c084509","fromSide":"top","toNode":"9121060332413fd5","toSide":"bottom","label":"join thread"},
		{"id":"59445f468ba4f342","fromNode":"ec1f3cc2e4ab5c15","fromSide":"right","toNode":"e373c2f1617f6085","toSide":"top","label":"call a timer for each core"},
		{"id":"a857b292454dc0ba","fromNode":"fa66f3386f9f5077","fromSide":"right","toNode":"466b81bdfb18ea2c","toSide":"left","label":"job over?"},
		{"id":"07a2d35be7ccf063","fromNode":"d7feb4fec86c6970","fromSide":"bottom","toNode":"993f8500eaea462b","toSide":"top","label":"init"},
		{"id":"28a64c4c82d5d7ae","fromNode":"8f093478bbfff797","fromSide":"right","toNode":"5561d46662ec9e5b","toSide":"left","label":"call"},
		{"id":"08cece035c4e509d","fromNode":"6c4ecbab9c5d7a8a","fromSide":"bottom","toNode":"537d320d024477a5","toSide":"top","label":"call"},
		{"id":"b91c0f38b3947a94","fromNode":"9211fb36752552ea","fromSide":"right","toNode":"6c4ecbab9c5d7a8a","toSide":"left","label":"!rdmflg?"},
		{"id":"3f2e375554d47cfe","fromNode":"ec1f3cc2e4ab5c15","fromSide":"left","toNode":"83c64aae90e0409d","toSide":"right","label":"call"},
		{"id":"ba63ea6645f1e209","fromNode":"42f64b2acaf42501","fromSide":"right","toNode":"9f2fe83dadc24af5","toSide":"left","fromEnd":"arrow"},
		{"id":"48a4e70f4733676e","fromNode":"83c64aae90e0409d","fromSide":"bottom","toNode":"1bc574c12922b5be","toSide":"top","label":"call"},
		{"id":"3d3da23d150f3bd0","fromNode":"83c64aae90e0409d","fromSide":"left","toNode":"a8de4aed3a46c63f","toSide":"right","label":"init"},
		{"id":"8551fe053c9958e3","fromNode":"ec1f3cc2e4ab5c15","fromSide":"left","toNode":"f7acb79a5bc217e5","toSide":"top","label":"call"},
		{"id":"aa575665bd3d4a77","fromNode":"f7acb79a5bc217e5","fromSide":"right","toNode":"ec1f3cc2e4ab5c15","toSide":"left","color":"2","label":"process configurations"},
		{"id":"15dfaec3aedd05ae","fromNode":"5561d46662ec9e5b","fromSide":"bottom","toNode":"42ce24d63349948a","toSide":"top","label":"call"},
		{"id":"f316dd927e5efe82","fromNode":"bb533130e355a147","fromSide":"right","toNode":"fd7d273366476647","toSide":"left","label":"call"},
		{"id":"2ddc0a49a9652817","fromNode":"9ecdd7db7df0c53b","fromSide":"right","toNode":"fd7d273366476647","toSide":"left","label":"call"},
		{"id":"33e95497e8a46463","fromNode":"5a1e61ccdbc3f3ea","fromSide":"bottom","toNode":"83c64aae90e0409d","toSide":"top","label":"call"},
		{"id":"0b19c581a9288ee8","fromNode":"ea49a7894b1bb4be","fromSide":"left","toNode":"4e36d857439193e0","toSide":"right","label":"call"},
		{"id":"6aca6da07a8b2448","fromNode":"cda9cdcf7f27e6da","fromSide":"left","toNode":"371116e11058490a","toSide":"right","label":"call"},
		{"id":"d67bf839b74631d1","fromNode":"d377c7df3f338286","fromSide":"bottom","toNode":"039f11ae8db528dc","toSide":"top","label":"contain xN"},
		{"id":"69ae832eae235bde","fromNode":"e975124d6ebff1be","fromSide":"right","toNode":"d377c7df3f338286","toSide":"left","label":"contain x1"},
		{"id":"b01f7b25a8c2d39b","fromNode":"ff63c2d239c6aa5c","fromSide":"bottom","toNode":"4e36d857439193e0","toSide":"left"},
		{"id":"dc3311df152e3aac","fromNode":"ff63c2d239c6aa5c","fromSide":"bottom","toNode":"371116e11058490a","toSide":"left"},
		{"id":"d34d89dc9ed22a71","fromNode":"c02223b37945f555","fromSide":"bottom","toNode":"ff63c2d239c6aa5c","toSide":"top","label":"call"},
		{"id":"a5b0186edca9f136","fromNode":"4f13b33d8baa6a3b","fromSide":"bottom","toNode":"ff63c2d239c6aa5c","toSide":"top","label":"call"},
		{"id":"ace4e42301720236","fromNode":"4855abf70aa48cd0","fromSide":"bottom","toNode":"a79c3351d57d28c2","toSide":"top","label":"call"},
		{"id":"d0069a1bfd6ef1cf","fromNode":"ec1f3cc2e4ab5c15","fromSide":"left","toNode":"5b076d74375ff120","toSide":"bottom","label":"call"},
		{"id":"257c4b8070d7aff6","fromNode":"cdfd91991821d0a6","fromSide":"right","toNode":"8a1f8cc89ebe32a5","toSide":"left","color":"3","label":"Failed to get free region?\ncall for area to increase limit"},
		{"id":"6b37ebb8835e9a6d","fromNode":"cdfd91991821d0a6","fromSide":"bottom","toNode":"b87529e010c9cc32","toSide":"top","color":"3","label":"attempt to increase area limit"},
		{"id":"37b3067fa832cd23","fromNode":"b87529e010c9cc32","fromSide":"right","toNode":"fd65ea4b87fa176b","toSide":"top","color":"4","label":"call for new region"},
		{"id":"a0799212c73a278d","fromNode":"b87529e010c9cc32","fromSide":"right","toNode":"6c6cc52bdffcd903","toSide":"top","color":"4","label":"call to check for overlaping"},
		{"id":"a4513896fb57b4ee","fromNode":"b87529e010c9cc32","fromSide":"left","toNode":"8168a04d3cfd8d65","toSide":"left","color":"4","label":"overlap validated?"},
		{"id":"efd7f3fe75f91f17","fromNode":"5b076d74375ff120","fromSide":"bottom","toNode":"a8de4aed3a46c63f","toSide":"top","label":"init"},
		{"id":"aa57717bf0340380","fromNode":"195e69fcabab2409","fromSide":"top","toNode":"edd4777840d4c721","toSide":"bottom","label":"call"},
		{"id":"1ca2d0a71a01d62e","fromNode":"36607e051c7379b4","fromSide":"top","toNode":"cdfd91991821d0a6","toSide":"right","color":"2","label":"call"},
		{"id":"c86b737c15e45b2f","fromNode":"98d14d3ab3b49cf5","fromSide":"top","toNode":"195e69fcabab2409","toSide":"bottom","label":"call"},
		{"id":"add46b9bf765cfd7","fromNode":"80d09e8f471be1b3","fromSide":"left","toNode":"ae75d0917ff485e0","toSide":"bottom","color":"5","label":"return"},
		{"id":"065a434b63f0585c","fromNode":"c0fe5fea091564c1","fromSide":"bottom","toNode":"d4d496299db63483","toSide":"top","label":"call"},
		{"id":"5ed5975d3c6c6c0a","fromNode":"ea49a7894b1bb4be","fromSide":"top","toNode":"f60082b7b26932ef","toSide":"bottom","color":"3","label":"call"},
		{"id":"21a6a25d3334e555","fromNode":"c0fe5fea091564c1","fromSide":"bottom","toNode":"f60082b7b26932ef","toSide":"bottom","color":"4","label":"call"},
		{"id":"95fa1e9f0fff7c11","fromNode":"cda9cdcf7f27e6da","fromSide":"top","toNode":"ea49a7894b1bb4be","toSide":"bottom","fromEnd":"arrow","color":"3"},
		{"id":"0ffc8c8154b58f42","fromNode":"cda9cdcf7f27e6da","fromSide":"bottom","toNode":"4e0d83c65f17720d","toSide":"right","color":"3","label":"call"},
		{"id":"4326d2b2561eeb57","fromNode":"c0fe5fea091564c1","fromSide":"bottom","toNode":"4e0d83c65f17720d","toSide":"top","color":"4","label":"call"},
		{"id":"e03f15dafe970817","fromNode":"d4d496299db63483","fromSide":"bottom","toNode":"2649b2021b07a440","toSide":"top","label":"call"},
		{"id":"6482d4f18c40f1b9","fromNode":"2649b2021b07a440","fromSide":"left","toNode":"637c213dd6fbc3e5","toSide":"right","label":"call"},
		{"id":"d77d3f4807b56e12","fromNode":"637c213dd6fbc3e5","fromSide":"top","toNode":"28ccab1b30292b51","toSide":"bottom","label":"call"},
		{"id":"8797f4c8bf0b93c6","fromNode":"2649b2021b07a440","fromSide":"bottom","toNode":"9211fb36752552ea","toSide":"top","label":"call"},
		{"id":"89f815b734145659","fromNode":"637c213dd6fbc3e5","fromSide":"bottom","toNode":"f4a61856146e5867","toSide":"top","color":"2","label":"call for new frame"},
		{"id":"de093d3571d13bd1","fromNode":"1bc574c12922b5be","fromSide":"left","toNode":"a8de4aed3a46c63f","toSide":"right","label":"format"},
		{"id":"986b32457d65fc7d","fromNode":"f0b64d9dd45a2ff3","fromSide":"bottom","toNode":"f4a61856146e5867","toSide":"top","color":"4","label":"pass free frames"},
		{"id":"9488de3f66ef9ad4","fromNode":"cdfd91991821d0a6","fromSide":"left","toNode":"1d2527a7dbeed805","toSide":"left","color":"2","label":"attempt to call for\nfree region"},
		{"id":"ad4ddc7695175a3d","fromNode":"ae75d0917ff485e0","fromSide":"bottom","toNode":"ff2694d796d4c052","toSide":"right","color":"5"},
		{"id":"237b01513ca008d3","fromNode":"d0e2e549e15f6a22","fromSide":"left","toNode":"d741ecb7893ee925","toSide":"right","label":"init"},
		{"id":"f03a67f29a489ae6","fromNode":"637c213dd6fbc3e5","fromSide":"left","toNode":"dd47a314e1c56648","toSide":"right","color":"5","label":"call"},
		{"id":"8dd7ea699110d6bb","fromNode":"08ee5012755f8b9e","fromSide":"bottom","toNode":"ce4eaf3bbbd73d78","toSide":"top","label":"call"},
		{"id":"0cc9e8f09cc843ee","fromNode":"8fed0f4f1dff21b9","fromSide":"right","toNode":"f4a61856146e5867","toSide":"bottom","color":"5","label":"call for free frame"},
		{"id":"5861ee5bcd005c51","fromNode":"8168a04d3cfd8d65","fromSide":"bottom","toNode":"8fed0f4f1dff21b9","toSide":"top","label":"call"},
		{"id":"725ca73c51ed6a4d","fromNode":"8168a04d3cfd8d65","fromSide":"top","toNode":"08ee5012755f8b9e","toSide":"right","color":"1","label":"call if some memory\nis in MEMSWAP"},
		{"id":"f854fbfe6913d2e3","fromNode":"cca61decfd5b2e94","fromSide":"right","toNode":"9211fb36752552ea","toSide":"left","label":"call read to get data from source page\ncall write to write data to destination page"},
		{"id":"59dedde6faf1eab8","fromNode":"ff2694d796d4c052","fromSide":"left","toNode":"24915e749cf8cb2a","toSide":"bottom","label":"call"},
		{"id":"24dc9b4781f17679","fromNode":"24915e749cf8cb2a","fromSide":"left","toNode":"95a78c02a9f9e335","toSide":"right","label":"init"},
		{"id":"eda25a235cb56fab","fromNode":"24915e749cf8cb2a","fromSide":"top","toNode":"7a5ac043a4fceaa3","toSide":"right","label":"call"},
		{"id":"a67c8e58005b9dcc","fromNode":"7a5ac043a4fceaa3","fromSide":"left","toNode":"8bd0be18f540c48b","toSide":"right","label":"init"},
		{"id":"3934bc6b106e0046","fromNode":"24915e749cf8cb2a","fromSide":"bottom","toNode":"57f73dee51e1166c","toSide":"right","color":"3","label":"call"},
		{"id":"3c7c4c68de4e5b40","fromNode":"cda9cdcf7f27e6da","fromSide":"bottom","toNode":"908f47a9f951ba07","toSide":"right","color":"1","label":"call"},
		{"id":"e78e5e0d0576a95e","fromNode":"9211fb36752552ea","fromSide":"left","toNode":"908f47a9f951ba07","toSide":"right","color":"5","label":"call"}
	]
}